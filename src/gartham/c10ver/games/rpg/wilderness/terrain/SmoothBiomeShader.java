package gartham.c10ver.games.rpg.wilderness.terrain;

import java.util.Random;

import org.alixia.javalibrary.JavaTools;

import gartham.c10ver.games.rpg.wilderness.Emoji;
import gartham.c10ver.games.rpg.wilderness.Location;

public class SmoothBiomeShader implements BiomeShader {

	private final Emoji[] emojis = Emoji.values();

	private final class Vec {
		private final double x, y;

		public Vec(double x, double y) {
			this.x = x;
			this.y = y;
		}

	}

	@Override
	public void shade(String[][] tile, Seed seed, Location tileLocation) {
//		Vec[][] grads = new Vec[tile.length + 1][tile[0].length + 1];
//
//		for (int i = 0; i < grads.length; i++)
//			for (int j = 0; j < grads.length; j++) {
//				double sqr = r.nextDouble();
//				grads[i][j] = new Vec(Math.sqrt(sqr), Math.sqrt(1 - sqr));
//			}

		// Instead of correlating variables, we'll have each corner be completely
		// random.
		// To do this, every *other* tile will be "responsible" for generating the
		// values at corners.
		// Tiles that do not generate values themselves will rely on the values
		// generated by their adjacent tiles.

		double tl = new Random(seed.getSeed() + JavaTools.hash(tileLocation.getX(), tileLocation.getY())).nextDouble(),
				tr = new Random(seed.getSeed() + JavaTools.hash(tileLocation.getX() + 1, tileLocation.getY()))
						.nextDouble(),
				bl = new Random(seed.getSeed() + JavaTools.hash(tileLocation.getX(), tileLocation.getY() - 1))
						.nextDouble(),
				br = new Random(seed.getSeed() + JavaTools.hash(tileLocation.getX() + 1, tileLocation.getY() - 1))
						.nextDouble();

		{
			Random r = new Random(seed.getSeed());
			long s = seed.getSeed();

			Random cornerGen = new Random(
					s ^ Long.rotateLeft(((long) tileLocation.getX()) << 32 | tileLocation.getY(), r.nextInt(64)));
			tl = cornerGen.nextDouble();// Every tile generates its own top left coordinate. For this tile's other
										// corners, we have to invoke other tiles.
			cornerGen.setSeed(
					s ^ Long.rotateLeft(((long) tileLocation.getX() + 1) << 32 | tileLocation.getY(), r.nextInt(64)));
			tr = cornerGen.nextDouble();

			cornerGen.setSeed(
					Long.rotateLeft(((long) tileLocation.getX()) << 32 | tileLocation.getY() - 1, r.nextInt(64)));
			bl = cornerGen.nextDouble();

			cornerGen.setSeed(
					Long.rotateLeft(((long) tileLocation.getX() + 1) << 32 | tileLocation.getY() - 1, r.nextInt(64)));
			br = cornerGen.nextDouble();

			System.out.println(tileLocation + "[" + tl + ", " + tr + ", " + br + ", " + bl + "]");
		}

		// Bilinearly interpolate between randomly generated points.

		for (int i = 0; i < tile.length; i++) {
			for (int j = 0; j < tile[i].length; j++) {
				double res = bilinearlyInterpolate(bl, br, tl, tr, tile[0].length, 0, 0, tile.length, j, i);
				tile[i][j] = emojis[(int) (res * emojis.length)].getValue();
			}
		}
	}

	private static double bilinearlyInterpolate(double bottomLeft, double bottomRight, double topLeft, double topRight,
			double rightXPos, double leftXPos, double bottomYPos, double topYPos, double x, double y) {
		double interpXY1 = (rightXPos - x) / (rightXPos - leftXPos) * bottomLeft
				+ (x - leftXPos) / (rightXPos - leftXPos) * bottomRight;
		double interpXY2 = (rightXPos - x) / (rightXPos - leftXPos) * topLeft
				+ (x - leftXPos) / (rightXPos - leftXPos) * topRight;

		double result = (topYPos - y) / (topYPos - bottomYPos) * interpXY1
				+ (y - bottomYPos) / (topYPos - bottomYPos) * interpXY2;
		return result;
	}

}
